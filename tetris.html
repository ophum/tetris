<html>
<head>

</head>
<style>

*{
  padding: 0;
  margin: 0;
}

/* ゲーム画面表示場所の大きさとか */
#display {
  width: calc(24px * 12);
  height: calc(24px * 22);
}

/* 1マスの大きさとか色(デフォルト 黒) */
.cell {
  width: 22px;
  height: 22px;
  display:block;
  float: left;
  background-color: rgb(32, 32, 32);
  border-left: 1px solid rgb(64, 64, 64);
  border-top: 1px solid rgb(64, 64, 64);
  border-right: 1px solid rgb(16, 16, 16);
  border-bottom: 1px solid rgb(16, 16, 16);
}

/* 外側の壁用のマスの色(灰色) */
.wall {
  background-color: rgb(128, 128, 128);
  border-left: 1px solid rgb(192, 192, 192);
  border-top: 1px solid rgb(192, 192, 192);
  border-right: 1px solid rgb(64, 64, 64);
  border-bottom: 1px solid rgb(64, 64, 64);
}

</style>
<body> 

  <!-- 表示場所 -->
  <div id="display"></div>

<script>

let Cell = {
  Wall : 1,
};
// カウンタ
var cnt = 0;

// 出力用メモリ
var vram = [
    [1,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,1],
    [1,1,1,1,1,1,1,1,1,1,1,1],
  ];

// ゲームを管理するためのフィールド
var field = [
    [1,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,1],
    [1,1,1,1,1,1,1,1,1,1,1,1],
  ];

// ブロックのでーた 
function Block(x, y, type) {
  this.x = x;
  this.y = y;
  this.type = type;
  this.status = 0;
}

// 各ブロックを格納する
let block_status = [0, 1, 1, 3, 3, 3, 1];
let blocks = [
  [
    [1,1],
    [1,1]
  ],
  [
    [1,0],
    [1,1],
    [0,1]
  ],
  [
    [0,1],
    [1,1],
    [1,0]
  ],
  [
    [1,0],
    [1,0],
    [1,1]
  ],
  [
    [0,1],
    [0,1],
    [1,1]
  ],
  [
    [1,0],
    [1,1],
    [1,0]
  ],
  [
    [1,1,1,1]
  ]

];
var block = new Block(4, 0, 1);

// vramをdisplayへ出力(vram to html)
let disp = function() {
  let d = document.getElementById("display"); // 出力場所の要素を取得

  var s = ""; // displayへ書き込むhtmlを格納する変数

  for(var i = 0; i < 22; i++) {
    for(var j = 0; j < 12; j++) {
      switch(vram[i][j]) {
      case Cell.Wall:
        s += "<div class='cell wall'></div>";
        break;
      default: // それ以外
        s += "<div class='cell'></div>";
        break;
      }
    }
  }

  d.innerHTML = s; // 要素に書き込み
};

let rotate1 = function(arr) {
  let width = arr[0].length;
  let height = arr.length;

}
// 配列コピー
// sa : コピー元配列
// da : コピー先配列
// sx : コピー元のx座標
// sy : コピー元のy座標
// dx : コピー先のx座標
// dy : コピー先のy座標
// width : コピーする幅
// height : コピーする高さ
// ignore : コピーしない値
let copy = function(sa, da, sx, sy, dx, dy, ignore, isRotate) {
  let width = sa[0].length;
  let height = sa.length;
  for(var i = 0; i < height; i++) {
    for(var j = 0; j < width; j++) {
      if(sa[sy + i][sx + j] == ignore) continue;
      da[dy + i][dx + j] = sa[sy + i][sx + j];
  }
  }
};

// btypeなブロックが(x, y)な座標に設置できるか
let checkOkeru = function(btype, x, y) {
  var b = blocks[btype];
  let w = b[0].length;
  let h = b.length;
  for(var i = y; i < y + h; i++) {
    for(var j = x; j < x + w; j++) {
    if(b[i-y][j-x] == 0) continue;
    if(field[i][j] != 0) return false;
  }
  }
  return true;
};

// 描画関係
let graph = function() {
  copy(field, vram, 0, 0, 0, 0, -1);
  copy(blocks[block.type], vram, 0, 0, block.x, block.y, 0);
  disp();
};

let process = function() {
  if(checkOkeru(block.type, block.x, block.y + 1)) block.y++;
  else next();
};

let delline = function(y) {
  for(var i = y; i > 0; i--) {
    for(var j = 1; j < 11; j++) {
      field[i][j] = field[i-1][j];
    }
  }
};

let next = function() {  
  // fieldに固定
  copy(blocks[block.type], field, 0, 0, block.x, block.y, 0);
  graph();
  
  for(var i = 0; i < 21; i++){
    var cnt = 0;
    for(var j = 1; j < 11; j++){
      cnt++;
      if(field[i][j] == 0) break;
    }
    if(cnt == 10) delline(i);
  }
  // 次のブロックを登録
  block.type = Math.floor(Math.random() * (7));
  block.x = 4;
  block.y = 0;
};

// main loop
let loop = function() {
  console.log(cnt++);
  graph();
  process();
  setTimeout(loop, 1000);
};

// キーイベント
document.addEventListener("keydown", function(e) {
  console.log("keycode = " + e.keyCode);
  switch(e.keyCode) {
  case 37: // ←
    if(checkOkeru(block.type, block.x - 1, block.y)) block.x--;
    break;
  case 39: // →
    if(checkOkeru(block.type, block.x + 1, block.y)) block.x++;
    break;
  case 40: // ↓
    process();
    break;
  case 65: // 'a'
    block.status--;
    if(block.status < 0) block.status = block_status[block.type];
    break;
  case 83: // 's'
    block.status++;
    if(block.status > block_status[block.type]) block.status = 0;
    break;
  }
  
  graph();
});
loop();
</script>
</body>
</html>
